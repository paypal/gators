{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "6288ceef",
   "metadata": {},
   "source": [
    "# pipeline templates"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "02c2ca22",
   "metadata": {},
   "outputs": [],
   "source": [
    "# data cleaning\n",
    "from gators.data_cleaning import (\n",
    "    ConvertColumnDatatype,\n",
    "    DropHighNaNRatio,\n",
    "    DropLowCardinality,\n",
    "    DropHighCardinality,\n",
    "    DropDatatypeColumns,\n",
    ")\n",
    "# imputers\n",
    "from gators.imputers import (\n",
    "    NumericsImputer, \n",
    "    ObjectImputer,\n",
    ")\n",
    "# encoders\n",
    "from gators.encoders import (\n",
    "    WOEEncoder, \n",
    "    TargetEncoder,\n",
    ")\n",
    "# binning\n",
    "from gators.binning import (\n",
    "    BinSingleTargetClassCategories,\n",
    "    BinRareCategories,\n",
    "    TreeBinning,\n",
    ")\n",
    "# feature generation\n",
    "from gators.feature_generation import (\n",
    "    PolynomialObjectFeatures,\n",
    ")\n",
    "# datetime feature generation\n",
    "from gators.feature_generation_dt import (\n",
    "    CyclicHourOfDay,\n",
    "    CyclicDayOfMonth,\n",
    "    CyclicDayOfWeek,\n",
    "    CyclicMonthOfYear,\n",
    "    OrdinalDayOfMonth,\n",
    "    OrdinalMonthOfYear,\n",
    "    OrdinalDayOfWeek,\n",
    "    OrdinalHourOfDay,\n",
    ")\n",
    "# feature selection\n",
    "from gators.feature_selection import (\n",
    "    InformationValue,\n",
    "    SelectFromModel,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0a70af5f",
   "metadata": {},
   "source": [
    "## data cleaning"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "fcc01ba4",
   "metadata": {},
   "outputs": [],
   "source": [
    "max_ratio = 0.9\n",
    "min_categories = 2\n",
    "max_categories =256\n",
    "min_ratio = 0.1\n",
    "strategy_num = 'mean'\n",
    "strategy_obj = 'constant'\n",
    "\n",
    "data_cleaning_steps = [\n",
    "    (\"DropHighNaNRatio\", DropHighNaNRatio(max_ratio=max_ratio)),\n",
    "    (\"DropLowCardinality\", DropLowCardinality(min_categories=min_categories)),\n",
    "    (\"DropHighCardinality\", DropHighCardinality(max_categories=max_categories)),\n",
    "    (\"BinRareCategories\", BinRareCategories(min_ratio=min_ratio)),\n",
    "    (\"NumericsImputer\", NumericsImputer(strategy=strategy_num, value=0)),\n",
    "    (\"ObjectImputer\", ObjectImputer(strategy=strategy_obj, value=\"MISSING\")),\n",
    "]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "43d53a52",
   "metadata": {},
   "source": [
    "## datetime feature generation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "0ecdb6aa",
   "metadata": {},
   "outputs": [],
   "source": [
    "datetime_columns = ['Date']\n",
    "datetime_steps = [\n",
    "    ('ConvertColumnDatatype', ConvertColumnDatatype(\n",
    "        columns=datetime_columns, datatype='datetime64[ns]')),\n",
    "    ('OrdinalHourOfDay', OrdinalHourOfDay(columns=datetime_columns)),\n",
    "    ('OrdinalDayOfWeek', OrdinalDayOfWeek(columns=datetime_columns)),\n",
    "    ('OrdinalDayOfMonth', OrdinalDayOfMonth(columns=datetime_columns)),\n",
    "    ('OrdinalMonthOfYear', OrdinalMonthOfYear(columns=datetime_columns)),\n",
    "    ('CyclicHourOfDay', CyclicHourOfDay(columns=datetime_columns)),\n",
    "    ('CyclicDayOfWeek', CyclicDayOfWeek(columns=datetime_columns)),\n",
    "    ('CyclicDayOfMonth', CyclicDayOfMonth(columns=datetime_columns)),\n",
    "    ('CyclicMonthOfYear', CyclicMonthOfYear(columns=datetime_columns)),\n",
    "]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6c3b379d",
   "metadata": {},
   "source": [
    "## polynomial object features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "ab018ff7",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor\n",
    "\n",
    "tree = DecisionTreeClassifier(random_state=0, min_samples_leaf=100)\n",
    "\n",
    "columns = list('columns')\n",
    "poynomial_object_features_steps = [\n",
    "    ('BinSingleTargetClassCategories', BinSingleTargetClassCategories()),\n",
    "    ('TreeBinning', TreeBinning(tree=tree)),\n",
    "    ('PolynomialObjectFeatures', \n",
    "         PolynomialObjectFeatures(columns=columns, degree=2)),\n",
    "    ('CleanCategories', BinRareCategories(min_ratio=0.1)), # min_ratio can be set to 0. \n",
    "    ('Encoder', WOEEncoder()), # if WOEEncoder binary problem or TargetEncoder() if regression problem.\n",
    "]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "313da73d",
   "metadata": {},
   "source": [
    "## feature selection"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b1a3f5e5",
   "metadata": {},
   "source": [
    "### univariate feature selection pipeline - binary classification"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "c3b60aaa",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor\n",
    "\n",
    "tree = DecisionTreeClassifier(random_state=0, min_samples_leaf=100)\n",
    "k = 50\n",
    "\n",
    "univariate_feature_selection_steps = [\n",
    "    ('BinSingleTargetClassCategories', BinSingleTargetClassCategories()),\n",
    "    ('TreeBinning', TreeBinning(tree=tree)),\n",
    "    ('InformationValue', InformationValue(k=k)),\n",
    "]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "de8c0212",
   "metadata": {},
   "source": [
    "### feature selection with the wrapper method pipeline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "495c7272",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/cpoli/gators38/lib/python3.8/site-packages/xgboost/compat.py:36: FutureWarning: pandas.Int64Index is deprecated and will be removed from pandas in a future version. Use pandas.Index with the appropriate dtype instead.\n",
      "  from pandas import MultiIndex, Int64Index\n"
     ]
    }
   ],
   "source": [
    "from sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor\n",
    "from xgboost import XGBClassifier, XGBRegressor\n",
    "tree = DecisionTreeClassifier(random_state=0, min_samples_leaf=100)\n",
    "model = XGBClassifier(random_seed=0)\n",
    "\n",
    "wrapper_feature_selection = [\n",
    "    ('BinSingleTargetClassCategories', BinSingleTargetClassCategories()),\n",
    "    ('TreeBinning', TreeBinning(tree=tree)), # tree clssifier or tree regressor \n",
    "    ('Encoder', WOEEncoder()), # if binary problem or TargetEncoder() if regression problem.\n",
    "    ('SelectFromModel', SelectFromModel(model=model, k=k))\n",
    "]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "68ae8450",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6749ca92",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "gators38",
   "language": "python",
   "name": "gators38"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
